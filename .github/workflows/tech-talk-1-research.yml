# ============================================================================
# TECH TALK PIPELINE â€” PHASE 1: RESEARCH
# ============================================================================
#
# WHAT THIS DOES:
#   Automatically researches source URLs when a new tech talk issue is created.
#   Copilot CLI fetches web content, downloads images, and extracts code examples.
#
# WHEN IT RUNS:
#   When a GitHub issue is opened or labeled with BOTH:
#     - "tech-talk"        (marks it as a tech talk issue)
#     - "tech-talk:intake" (marks it as ready for research)
#
# WHAT IT PRODUCES (committed to a new branch):
#   tech-talks/{topic}/research.md    â€” Full research findings from Copilot CLI
#   tech-talks/{topic}/images/        â€” Downloaded images from source URLs
#   tech-talks/{topic}/examples/      â€” Code samples extracted from sources
#
# WHAT HAPPENS NEXT:
#   This workflow automatically swaps the label to "tech-talk:planned",
#   which triggers Phase 2 (Content Planning) â€” no human action needed.
#
# RELATED FILES:
#   Prompt template:  .github/prompts/tech-talk/research-instructions.md
#   Issue template:   .github/ISSUE_TEMPLATE/tech-talk-request.yml
#   Phase 2 workflow: .github/workflows/tech-talk-2-plan.yml
# ============================================================================

name: "Tech Talk Phase 1: Research"

# "on:" defines WHEN this workflow runs.
# This workflow triggers when a GitHub issue is opened or has a label added.
on:
  issues:
    types: [opened, labeled]

# "jobs:" contains the actual work this workflow performs.
# Each job runs on a fresh virtual machine (ubuntu-latest).
jobs:
  research:
    name: Research Source URLs
    runs-on: ubuntu-latest # Use a Linux VM hosted by GitHub

    # "if:" is a guard â€” this job ONLY runs when both labels are present.
    # This prevents the job from running on unrelated issues.
    if: |
      contains(github.event.issue.labels.*.name, 'tech-talk') &&
      contains(github.event.issue.labels.*.name, 'tech-talk:intake')

    # "permissions:" controls what this workflow is allowed to do.
    # - issues: write   â†’ post comments on the issue
    # - contents: write â†’ create branches and push commits
    permissions:
      issues: write
      contents: write

    # "steps:" are the individual tasks that run IN ORDER, one after another.
    # If any step fails, the workflow stops (unless you handle the error).
    steps:
      # â”€â”€ SETUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Download the repo code so we can read/write files
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install GitHub Copilot CLI
        run: npm install -g @github/copilot

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install Python dependencies
        run: pip install requests

      # â”€â”€ EXTRACT ISSUE DATA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Parse the issue body to get the topic, URLs, question, etc.
      # These values are saved as "outputs" so later steps can use them
      # via: ${{ steps.extract.outputs.topic }}
      - name: Extract issue fields
        id: extract # "id" lets other steps reference this step's outputs
        uses: actions/github-script@v7 # Runs JavaScript with GitHub API access
        with:
          script: |
            const body = context.payload.issue.body || '';

            const extractField = (label) => {
              const regex = new RegExp(`### ${label}\\s*\\n\\s*([^#]+)`, 'i');
              const match = body.match(regex);
              return match ? match[1].trim() : '';
            };

            const topic = extractField('Tech Talk Topic');
            const sourceUrls = extractField('Source URLs');
            const primaryQuestion = extractField('Primary Question');
            const audience = extractField('Target Audience');
            const section = extractField('Index Section');
            const duration = extractField('Expected Duration');
            const guidance = extractField('Guidance \\(optional\\)');

            core.setOutput('topic', topic);
            core.setOutput('source_urls', sourceUrls);
            core.setOutput('primary_question', primaryQuestion || 'Not specified');
            core.setOutput('audience', audience || 'Mixed Audience');
            core.setOutput('section', section || 'Context & Customization');
            core.setOutput('duration', duration || '45 minutes');
            core.setOutput('guidance', guidance || 'No specific guidance provided');

      # â”€â”€ CREATE BRANCH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Create a dedicated Git branch for this tech talk.
      # All phases commit to this same branch. The branch name follows
      # the pattern: tech-talk/{topic}-{issue_number}
      # The branch name is saved as a step output so later steps can use it.
      - name: Create feature branch
        id: branch # Other steps use ${{ steps.branch.outputs.branch_name }}
        run: |
          TOPIC="${{ steps.extract.outputs.topic }}"
          BRANCH_NAME="tech-talk/${TOPIC}-${{ github.event.issue.number }}"
          git checkout -b "$BRANCH_NAME"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

      # â”€â”€ PREPARE DIRECTORIES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Create the folder structure where research artifacts will be saved
      - name: Create artifact directories
        run: |
          TOPIC="${{ steps.extract.outputs.topic }}"
          mkdir -p "tech-talks/${TOPIC}/images"
          mkdir -p "tech-talks/${TOPIC}/examples"

      # â”€â”€ STATUS COMMENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Post a comment on the issue so the user knows what's happening.
      # This uses the GitHub API (actions/github-script) to create the comment.
      # The comment body is built as a JavaScript array joined with newlines
      # to avoid YAML parsing issues with markdown table syntax.
      - name: Comment - Starting Research
        uses: actions/github-script@v7
        with:
          script: |
            const topic = '${{ steps.extract.outputs.topic }}';
            const body = [
              '## ğŸ” Phase 1 of 4: Research Started',
              '',
              '### Workflow Overview',
              '| Phase | Status | Trigger |',
              '|-------|--------|---------|',
              '| **1. Research** | ğŸ”„ In Progress | `tech-talk:intake` label (automatic) |',
              '| 2. Plan | â³ Pending | Automatic after research completes |',
              '| 3. Build | â³ Pending | `/approve-plan` comment (you review first) |',
              '| 4. Slides | â³ Pending | `tech-talk:slides` label (you add it) |',
              '',
              "### What's Happening Now",
              'Copilot CLI is researching source URLs, fetching web content, and gathering artifacts...',
              '',
              '| Field | Value |',
              '|-------|-------|',
              `| **Topic** | ${topic} |`,
              '| **Branch** | `${{ steps.branch.outputs.branch_name }}` |',
              '| **Question** | ${{ steps.extract.outputs.primary_question }} |',
              '| **Audience** | ${{ steps.extract.outputs.audience }} |',
              '| **Duration** | ${{ steps.extract.outputs.duration }} |',
              '',
              '> ğŸ‘¤ **No action needed from you** â€” Phase 2 will start automatically when research completes.',
            ].join('\n');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body,
            });

      # â”€â”€ COPILOT CLI: RESEARCH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # This is the main AI step. It:
      #   1. Builds a prompt by filling in template placeholders (sed command)
      #   2. Runs Copilot CLI with that prompt
      #   3. Saves the output as research.md
      #
      # The prompt template lives at: .github/prompts/tech-talk/research-instructions.md
      # "sed" replaces {{TOPIC}}, {{AUDIENCE}}, etc. with actual values.
      - name: Run Copilot CLI for research
        env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }} # Auth token for Copilot CLI
        run: |
          TOPIC="${{ steps.extract.outputs.topic }}"

          # Escape newlines in source URLs for sed
          SOURCE_URLS=$(echo '${{ steps.extract.outputs.source_urls }}' | sed ':a;N;$!ba;s/\n/\\n/g')

          # Build prompt from template
          sed -e "s|{{ISSUE_NUMBER}}|${{ github.event.issue.number }}|g" \
              -e "s|{{TOPIC}}|${TOPIC}|g" \
              -e "s|{{PRIMARY_QUESTION}}|${{ steps.extract.outputs.primary_question }}|g" \
              -e "s|{{AUDIENCE}}|${{ steps.extract.outputs.audience }}|g" \
              -e "s|{{DURATION}}|${{ steps.extract.outputs.duration }}|g" \
              -e "s|{{GUIDANCE}}|${{ steps.extract.outputs.guidance }}|g" \
              -e "s|{{SECTION}}|${{ steps.extract.outputs.section }}|g" \
              -e "s|{{SOURCE_URLS}}|${SOURCE_URLS}|g" \
              .github/prompts/tech-talk/research-instructions.md > research_prompt.txt

          # Run Copilot CLI with shell(curl) access for web search
          copilot -p @research_prompt.txt \
            --allow-tool 'shell(curl)' \
            > "tech-talks/${TOPIC}/research.md"

          echo "âœ… Research complete"

      # â”€â”€ DOWNLOAD IMAGES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Fetch images from each source URL using a Python helper script.
      # Images are saved to tech-talks/{topic}/images/ for use in the talk.
      - name: Download images from source URLs
        run: |
          TOPIC="${{ steps.extract.outputs.topic }}"
          SOURCE_URLS="${{ steps.extract.outputs.source_urls }}"

          # Download images from each source URL
          while IFS= read -r url; do
            url=$(echo "$url" | xargs)  # trim whitespace
            if [[ -n "$url" && "$url" =~ ^https?:// ]]; then
              echo "ğŸ“¸ Downloading images from: $url"
              python3 scripts/download-images.py "$url" "tech-talks/${TOPIC}/images" --limit 7 || echo "âš ï¸ Warning: Could not download images from $url"
            fi
          done <<< "$SOURCE_URLS"

          # List what was downloaded
          echo "ğŸ“ Downloaded images:"
          ls -la "tech-talks/${TOPIC}/images/" 2>/dev/null || echo "  (none)"

      # â”€â”€ EXTRACT CODE EXAMPLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Ask Copilot CLI to pull out code snippets from the research document
      # and save them as individual files in the examples/ directory.
      - name: Extract code examples from research
        env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          TOPIC="${{ steps.extract.outputs.topic }}"

          # Ask Copilot CLI to extract code examples from the research as separate files
          cat > extract_prompt.txt << 'PROMPT'
          Read the research document below. Extract each code example, configuration,
          or workflow definition into a separate file. For each example:

          1. Choose a descriptive filename (e.g., basic-config.yml, setup-workflow.yml, example-usage.py)
          2. Write ONLY the code/config content (no markdown, no explanation)
          3. Output in this exact format for each file:

          --- FILE: filename.ext ---
          [file contents]
          --- END FILE ---

          If there are no extractable code examples, output: NO_EXAMPLES

          Research document:
          PROMPT

          cat "tech-talks/${TOPIC}/research.md" >> extract_prompt.txt

          copilot -p @extract_prompt.txt > extracted_examples.txt

          # Parse and save extracted examples
          if ! grep -q "NO_EXAMPLES" extracted_examples.txt; then
            current_file=""
            while IFS= read -r line; do
              if [[ "$line" =~ ^---\ FILE:\ (.+)\ ---$ ]]; then
                current_file="${BASH_REMATCH[1]}"
                > "tech-talks/${TOPIC}/examples/${current_file}"
              elif [[ "$line" =~ ^---\ END\ FILE\ ---$ ]]; then
                current_file=""
              elif [[ -n "$current_file" ]]; then
                echo "$line" >> "tech-talks/${TOPIC}/examples/${current_file}"
              fi
            done < extracted_examples.txt
          fi

          echo "ğŸ“ Extracted examples:"
          ls -la "tech-talks/${TOPIC}/examples/" 2>/dev/null || echo "  (none)"

      # â”€â”€ HANDLE EMPTY DIRS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Git doesn't track empty folders. Adding .gitkeep ensures the
      # images/ and examples/ directories are committed even if empty.
      - name: Add .gitkeep to empty directories
        run: |
          TOPIC="${{ steps.extract.outputs.topic }}"
          # Ensure directories are committed even if empty
          [ -z "$(ls -A tech-talks/${TOPIC}/images/)" ] && touch "tech-talks/${TOPIC}/images/.gitkeep"
          [ -z "$(ls -A tech-talks/${TOPIC}/examples/)" ] && touch "tech-talks/${TOPIC}/examples/.gitkeep"

      # â”€â”€ COMMIT & PUSH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Save all research artifacts to Git and push the branch to GitHub.
      # This makes the research available to Phase 2.
      - name: Commit and push artifacts
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          TOPIC="${{ steps.extract.outputs.topic }}"
          git add "tech-talks/${TOPIC}/"
          git commit -m "Phase 1: Research artifacts for ${TOPIC} (Issue #${{ github.event.issue.number }})

          - research.md: Source URL research findings
          - images/: Visual assets from source URLs
          - examples/: Code samples extracted from sources"

          git push origin "${{ steps.branch.outputs.branch_name }}"

      # â”€â”€ COMPLETION COMMENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Post a summary comment with artifact links and quality indicators.
      # Quality is based on line count: ğŸŸ¢ â‰¥200 lines, ğŸŸ¡ â‰¥100, ğŸ”´ <100
      - name: Post completion status
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const topic = '${{ steps.extract.outputs.topic }}';
            const branch = '${{ steps.branch.outputs.branch_name }}';

            // Count artifacts
            const imgDir = `tech-talks/${topic}/images`;
            const exDir = `tech-talks/${topic}/examples`;
            const imgCount = fs.readdirSync(imgDir).filter(f => f !== '.gitkeep').length;
            const exCount = fs.readdirSync(exDir).filter(f => f !== '.gitkeep').length;

            // Count research lines for quality indicator
            const researchContent = fs.readFileSync(`tech-talks/${topic}/research.md`, 'utf8');
            const researchLines = researchContent.split('\n').length;
            const qualityEmoji = researchLines >= 200 ? 'ğŸŸ¢' : researchLines >= 100 ? 'ğŸŸ¡' : 'ğŸ”´';

            const body = [
              '## âœ… Phase 1 of 4: Research Complete',
              '',
              '### Artifacts Committed to Branch',
              '| File | Description | Quality |',
              '|------|-------------|---------|',
              `| [\`tech-talks/${topic}/research.md\`](https://github.com/${context.repo.owner}/${context.repo.repo}/blob/${branch}/tech-talks/${topic}/research.md) | Research findings (${researchLines} lines) | ${qualityEmoji} |`,
              `| \`tech-talks/${topic}/images/\` | ${imgCount} image(s) downloaded | ${imgCount > 0 ? 'ğŸŸ¢' : 'ğŸŸ¡'} |`,
              `| \`tech-talks/${topic}/examples/\` | ${exCount} example(s) extracted | ${exCount > 0 ? 'ğŸŸ¢' : 'ğŸŸ¡'} |`,
              '',
              '### Workflow Progress',
              '| Phase | Status | Trigger |',
              '|-------|--------|---------|',
              '| ~~1. Research~~ | âœ… Complete | â€” |',
              '| **2. Plan** | ğŸ”„ Starting now... | Automatic |',
              '| 3. Build | â³ Pending | `/approve-plan` comment |',
              '| 4. Slides | â³ Pending | `tech-talk:slides` label |',
              '',
              '> ğŸ‘¤ **No action needed** â€” Phase 2 (Content Planning) is starting automatically.',
            ].join('\n');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body,
            });

      # â”€â”€ TRIGGER PHASE 2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Swap the issue label from "tech-talk:intake" â†’ "tech-talk:planned".
      # This label change automatically triggers the Phase 2 workflow.
      # No human action is needed between Phase 1 and Phase 2.
      - name: Progress to Phase 2
        uses: actions/github-script@v7
        with:
          script: |
            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                name: 'tech-talk:intake'
              });
            } catch (e) { /* label may not exist */ }

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['tech-talk:planned']
            });
